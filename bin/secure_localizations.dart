// ignore_for_file: avoid_print

import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'dart:typed_data';

import 'package:yaml/yaml.dart';

const String _defaultArbDir = 'lib/l10n';
const String _defaultOutputDir = 'lib/l10n';
const String _defaultCommand = 'gen-l10n';
const String _helperFileName = 'secure_encryption_helper.dart';

void main() async {
  try {
    print("üîí Secure L10n Starting...");

    // 1. Load Config from User's pubspec.yaml
    final Map<String, dynamic> config = _loadConfig();
    final int key =
        (config['key'] ?? Random().nextInt(100000000) + 100000) as int;
    final String outputDir =
        (config['output_dir'] ?? _defaultOutputDir) as String;
    final String command = (config['command'] ?? _defaultCommand) as String;
    final String arbDir = (config['arb_dir'] ?? _defaultArbDir) as String;

    print(
        "üîë Encryption Key: $key (${config.containsKey('key') ? 'Fixed' : 'Random Generated'})");

    // 2. Generate Helper Class (Creates the file the IDE is looking for)
    _generateHelperClass(outputDir, key);

    // 3. Encrypt ARBs
    final Directory backupDir = Directory('.dart_tool/l10n_backup');
    if (!backupDir.existsSync()) backupDir.createSync(recursive: true);
    _encryptArbFiles(arbDir, backupDir, key);

    // 4. Run Generator
    print("‚öôÔ∏è  Running localization generator...");
    final List<String> lstCmd = command.replaceAll("flutter ", "").split(" ");
    final String flutterCmd = Platform.isWindows ? 'flutter.bat' : 'flutter';
    final ProcessResult result =
        await Process.run(flutterCmd, lstCmd, runInShell: true);

    if (result.exitCode != 0) {
      print("‚ùå Generator Error: ${result.stderr}");
      return;
    }

    // 5. Patch the Generated Localization Files
    _patchGeneratedFiles(outputDir);

    print("‚úÖ Done! Your localizations are now secured.");
  } catch (e, stack) {
    print("üí• Fatal Error: $e");
    print(stack);
  } finally {
    _restoreArbFiles();
  }
}

Map<String, dynamic> _loadConfig() {
  final File file = File('pubspec.yaml');
  if (!file.existsSync()) return <String, dynamic>{};

  final dynamic yaml = loadYaml(file.readAsStringSync());
  final dynamic config = yaml['secure_localizations'];

  if (config == null) return <String, dynamic>{};

  // Using Map.from ensures we convert YamlMap to a standard Dart Map
  return Map<String, dynamic>.from(config as Map);
}

void _generateHelperClass(String outputDirPath, int key) {
  final Directory dir = Directory(outputDirPath);
  if (!dir.existsSync()) dir.createSync(recursive: true);

  final File file = File('$outputDirPath/$_helperFileName');
  file.writeAsStringSync('''
// AUTO-GENERATED BY secure_localizations. DO NOT EDIT.
import 'dart:convert';
import 'dart:typed_data';

class SecureEncryption {
  static const int _key = $key;
  static const int _byteKey = _key & 0xFF;

  static String decode(String encodedBase64) {
    try {
      final Uint8List bytes = base64.decode(encodedBase64);
      final List<int> decoded = bytes.map((b) => b ^ _byteKey).toList();
      return utf8.decode(decoded);
    } catch (e) {
      return encodedBase64;
    }
  }
}
''');
  print("üõ†Ô∏è  Created Helper: ${file.path}");
}

void _encryptArbFiles(String arbPath, Directory backupDir, int key) {
  final Directory dir = Directory(arbPath);
  final Iterable<FileSystemEntity> arbFiles =
      dir.listSync().where((FileSystemEntity f) => f.path.endsWith('.arb'));
  final int byteKey = key & 0xFF;

  for (FileSystemEntity entity in arbFiles) {
    if (entity is File) {
      final String fileName = entity.path.split(Platform.pathSeparator).last;
      final String content = entity.readAsStringSync();
      final Map<String, dynamic> map =
          jsonDecode(content) as Map<String, dynamic>;
      final Map<String, dynamic> encryptedMap = <String, dynamic>{};

      map.forEach((String k, dynamic v) {
        if (k.startsWith('@')) {
          encryptedMap[k] = v;
        } else {
          final Uint8List bytes = utf8.encode(v.toString());
          final List<int> xor = bytes.map((int b) => b ^ byteKey).toList();
          encryptedMap[k] = base64.encode(Uint8List.fromList(xor));
        }
      });

      final File backup = File('${backupDir.path}/$fileName');
      entity.copySync(backup.path);
      entity.writeAsStringSync(jsonEncode(encryptedMap));
    }
  }
}

void _restoreArbFiles() {
  final Directory backupDir = Directory('.dart_tool/l10n_backup');
  final Directory arbDir = Directory(_defaultArbDir);

  if (backupDir.existsSync()) {
    print("‚è™ Restoring original ARB files...");
    for (FileSystemEntity entity in backupDir.listSync()) {
      if (entity is File) {
        final String fileName = entity.path.split(Platform.pathSeparator).last;
        entity.copySync('${arbDir.path}/$fileName');
      }
    }
    backupDir.deleteSync(recursive: true);
  }
}

void _patchGeneratedFiles(String helperDir) {
  final List<File> targets = <File>[];

  // 1. Search in the directory where you expect the output to be
  // We check the helperDir (which is lib/l10n by default in your code)
  final Directory outputSearchDir = Directory(helperDir);

  if (outputSearchDir.existsSync()) {
    print("üîé Searching for generated files in: ${outputSearchDir.path}");
    outputSearchDir.listSync(recursive: true).forEach((FileSystemEntity e) {
      if (e is File &&
          e.path.endsWith('.dart') &&
          e.path.contains('app_localizations_')) {
        targets.add(e);
      }
    });
  }

  if (targets.isEmpty) {
    print(
        "‚ö†Ô∏è No generated localization files found in $helperDir. Checking .dart_tool as fallback...");
    // Fallback search just in case
    final Directory fallback = Directory('.dart_tool/flutter_gen/gen_l10n');
    if (fallback.existsSync()) {
      for (var e in fallback.listSync()) {
        if (e is File && e.path.contains('app_localizations_')) targets.add(e);
      }
    }
  }

  if (targets.isEmpty) {
    print(
        "‚ùå ERROR: Could not find any files to patch. Check your 'output_dir' in pubspec.yaml.");
    return;
  }

  final dynamic pubspec = loadYaml(File('pubspec.yaml').readAsStringSync());
  final dynamic packageName = pubspec['name'];

  // 2. Fix the import path logic
  // If helperDir is 'lib/l10n', we need 'package:project/l10n/helper.dart'
  String formattedDir = helperDir;
  if (formattedDir.startsWith('lib/')) {
    formattedDir = formattedDir.substring(4);
  } else if (formattedDir == 'lib') {
    formattedDir = '';
  }

  final String importPath = formattedDir.isEmpty
      ? 'package:$packageName/$_helperFileName'
      : 'package:$packageName/$formattedDir/$_helperFileName';

  for (File file in targets) {
    _applyPatch(file, importPath);
  }
}

void _applyPatch(File file, String importPath) {
  String content = file.readAsStringSync();
  if (content.contains('SecureEncryption.decode')) return;

  final String fileName = file.path.split(Platform.pathSeparator).last;
  final RegExpMatch? localeMatch =
      RegExp(r'_([a-z]{2})\.dart').firstMatch(fileName);
  final String locale = localeMatch?.group(1) ?? 'xx';

  content = "import '$importPath';\n$content";
  final RegExp pattern = RegExp(r"(=>|return)\s+'([^']+)'");

  final String patched = content.replaceAllMapped(pattern, (Match match) {
    final String prefix = match.group(1)!;
    final String val = match.group(2)!;

    // Ignore locale identifiers and very short UI strings (optional)
    if (val == locale) return match.group(0)!;

    return "$prefix SecureEncryption.decode('$val')";
  });

  file.writeAsStringSync(patched);
  print("‚ú® Patched $fileName");
}
