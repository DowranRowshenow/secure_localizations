// ignore_for_file: avoid_print

import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'dart:typed_data';

import 'package:yaml/yaml.dart';

const String _defaultOutputDir = 'lib/l10n';
const String _defaultCommand = 'gen-l10n';
const String _helperFileName = 'secure_encryption_helper.dart';

void main() async {
  try {
    print("üîí Secure L10n Starting...");

    // 1. Load Config
    final Map<String, dynamic> config = _loadConfig();
    final int key =
        (config['key'] ?? Random().nextInt(100000000) + 100000) as int;
    final String outputDir =
        (config['output_dir'] ?? _defaultOutputDir) as String;
    final String command = (config['command'] ?? _defaultCommand) as String;

    print(
        "üîë Encryption Key: $key (${config.containsKey('key') ? 'Fixed' : 'Random Generated'})");

    // 2. Generate Helper Class
    _generateHelperClass(outputDir, key);

    // 3. Run Generator (On PLAIN ARB files so variables are generated correctly)
    print("‚öôÔ∏è  Running localization generator...");
    final List<String> lstCmd = command.replaceAll("flutter ", "").split(" ");
    final String flutterCmd = Platform.isWindows ? 'flutter.bat' : 'flutter';

    final ProcessResult result =
        await Process.run(flutterCmd, lstCmd, runInShell: true);

    if (result.exitCode != 0) {
      print("‚ùå Generator Error: ${result.stderr}");
      return;
    }

    // 4. Patch and Encrypt the Generated Files
    _patchGeneratedFiles(outputDir, key);

    print("‚úÖ Done! Your localizations are now secured.");
  } catch (e, stack) {
    print("üí• Fatal Error: $e");
    print(stack);
  }
}

// --- HELPER FUNCTIONS ---

Map<String, dynamic> _loadConfig() {
  final File file = File('pubspec.yaml');
  if (!file.existsSync()) return <String, dynamic>{};
  final dynamic yaml = loadYaml(file.readAsStringSync());
  final dynamic config = yaml['secure_localizations'];
  if (config == null) return <String, dynamic>{};
  return Map<String, dynamic>.from(config as YamlMap);
}

void _generateHelperClass(String outputDirPath, int key) {
  final Directory dir = Directory(outputDirPath);
  if (!dir.existsSync()) dir.createSync(recursive: true);

  final File file = File('$outputDirPath/$_helperFileName');
  // NOTE: We inject the $key here so the helper knows how to decrypt
  file.writeAsStringSync('''
// AUTO-GENERATED BY secure_localizations. DO NOT EDIT.
import 'dart:convert';
import 'dart:typed_data';

class SecureEncryption {
  static const int _key = $key;
  static const int _byteKey = _key & 0xFF;

  static String decode(String encodedBase64) {
    try {
      final Uint8List bytes = base64.decode(encodedBase64);
      final List<int> decoded = bytes.map((int b) => b ^ _byteKey).toList();
      return utf8.decode(decoded);
    } catch (e) {
      return encodedBase64;
    }
  }
}
''');
  print("üõ†Ô∏è  Created Helper: ${file.path}");
}

void _patchGeneratedFiles(String helperDir, int key) {
  final List<File> targets = <File>[];
  final Directory outputSearchDir = Directory(helperDir);

  if (outputSearchDir.existsSync()) {
    print("üîé Searching for generated files in: ${outputSearchDir.path}");
    outputSearchDir.listSync(recursive: true).forEach((FileSystemEntity e) {
      if (e is File &&
          e.path.endsWith('.dart') &&
          e.path.contains('app_localizations_')) {
        targets.add(e);
      }
    });
  }

  // Fallback search
  if (targets.isEmpty) {
    print(
        "‚ö†Ô∏è No generated files in $helperDir. Checking default .dart_tool...");
    final Directory fallback = Directory('.dart_tool/flutter_gen/gen_l10n');
    if (fallback.existsSync()) {
      for (FileSystemEntity e in fallback.listSync()) {
        if (e is File && e.path.contains('app_localizations_')) targets.add(e);
      }
    }
  }

  if (targets.isEmpty) {
    print("‚ùå ERROR: Could not find files to patch.");
    return;
  }

  final dynamic pubspec = loadYaml(File('pubspec.yaml').readAsStringSync());
  final dynamic packageName = pubspec['name'];

  String formattedDir = helperDir;
  if (formattedDir.startsWith('lib/')) {
    formattedDir = formattedDir.substring(4);
  } else if (formattedDir == 'lib') {
    formattedDir = '';
  }

  final String importPath = formattedDir.isEmpty
      ? 'package:$packageName/$_helperFileName'
      : 'package:$packageName/$formattedDir/$_helperFileName';

  for (File file in targets) {
    _applyPatch(file, importPath, key);
  }
}

void _applyPatch(File file, String importPath, int key) {
  String content = file.readAsStringSync();
  if (content.contains('SecureEncryption.decode')) return;

  final String fileName = file.path.split(Platform.pathSeparator).last;
  final RegExpMatch? localeMatch =
      RegExp(r'_([a-z]{2})\.dart').firstMatch(fileName);
  final String locale = localeMatch?.group(1) ?? 'xx';

  content = "import '$importPath';\n$content";

  // Matcher for: => '...' OR return '...';
  final RegExp pattern =
      RegExp(r'(=>|return)\s+[\x27\x22]([^\x27\x22]+)[\x27\x22]');

  final String patched = content.replaceAllMapped(pattern, (Match match) {
    final String prefix = match.group(1)!;
    final String fullValue = match.group(2)!;

    if (fullValue == locale) return match.group(0)!;

    if (fullValue.contains(r'$')) {
      // 1. Regex to find variables: matches $name or ${name}
      final RegExp varRegex = RegExp(r'(\$[a-zA-Z0-9_]+|\$\{[^}]+\})');
      final List<String> segments = <String>[];
      int lastMatchEnd = 0;

      for (final RegExpMatch m in varRegex.allMatches(fullValue)) {
        // 2. Encrypt text BEFORE the variable
        if (m.start > lastMatchEnd) {
          final text = fullValue.substring(lastMatchEnd, m.start);
          segments
              .add("SecureEncryption.decode('${_encryptString(text, key)}')");
        }

        // 3. Clean the variable for concatenation
        // Converts "$version" -> "version" or "${version}" -> "version"
        String varName = m.group(0)!;
        if (varName.startsWith(r'${')) {
          varName = varName.substring(2, varName.length - 1);
        } else {
          varName = varName.substring(1);
        }
        segments.add(varName);

        lastMatchEnd = m.end;
      }

      // 4. Encrypt text AFTER the last variable
      if (lastMatchEnd < fullValue.length) {
        final text = fullValue.substring(lastMatchEnd);
        segments.add("SecureEncryption.decode('${_encryptString(text, key)}')");
      }

      return "$prefix ${segments.join(' + ')}";
    }

    return "$prefix SecureEncryption.decode('${_encryptString(fullValue, key)}')";
  });

  file.writeAsStringSync(patched);
  print("‚ú® Patched $fileName");
}

String _encryptString(String plainText, int key) {
  final int byteKey = key & 0xFF;
  final Uint8List bytes = utf8.encode(plainText);
  final List<int> xor = bytes.map((int b) => b ^ byteKey).toList();
  return base64.encode(Uint8List.fromList(xor));
}
